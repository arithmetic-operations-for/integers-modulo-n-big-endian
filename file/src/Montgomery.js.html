<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/Montgomery.js | @aureooms/js-modular-arithmetic-big-endian</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<link rel="stylesheet" href="./inject/css/0-style.css"><script src="./inject/script/0-header.js"></script><meta name="description" content="Modular arithmetic for JavaScript"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="@aureooms/js-modular-arithmetic-big-endian"><meta property="twitter:description" content="Modular arithmetic for JavaScript"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  <a href="./manual/index.html" data-ice="manualHeaderLink">Manual</a>
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/aureooms/js-modular-arithmetic-big-endian"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/Montgomery.js~Montgomery.html">Montgomery</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-_iadd">_iadd</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-_isub">_isub</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-_montgomery">_montgomery</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-_mul">_mul</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-_redc">_redc</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-modN">modN</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-modR">modR</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/Montgomery.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import {
	_alloc as n_alloc,
	_zeros as n_zeros,
	_reset as n_reset,
	_copy as n_copy,
	jz as njz,
	_extended_euclidean_algorithm as n_extended_euclidean_algorithm,
	_trim_positive as n_trim_positive,
	_sub as n_sub,
	convert as nconvert,
} from &apos;@aureooms/js-integer-big-endian&apos;;

import _mul from &apos;./_mul.js&apos;;
import _iadd from &apos;./_iadd.js&apos;;
import _isub from &apos;./_isub.js&apos;;
import _redc from &apos;./_redc.js&apos;;
import _montgomery from &apos;./_montgomery.js&apos;;
import modR from &apos;./modR.js&apos;;
import modN from &apos;./modN.js&apos;;

export default class Montgomery {
	constructor(b, N) {
		const {k, M, R, R2, R3} = _montgomery(b, N);
		this.b = b;
		this.N = N;
		this.k = k;
		this.M = M;
		this.R = R;
		this.R2 = R2;
		this.R3 = R3;
		// Use shared/pooled memory ?
	}

	one() {
		return this.R;
	}

	zero() {
		return n_zeros(this.k);
	}

	from(x) {
		// Conversion into Montgomery form is done by computing .
		// aR mod N = REDC((a mod N)(R^2 mod N))
		const _2kp1 = 2 * this.k + 1;
		const red = n_zeros(_2kp1); // TODO Use UintXArray ?
		const amodN = modN(this.b, this.N, x);
		_mul(this.b, this.N, this.M, this.R2, amodN, red);
		// TODO many unnecessary copies/alloc can be avoided by
		// allowing array offsets in methods.
		return modR(this.k, red);
	}

	out(aRmodN) {
		// Conversion out of Montgomery form is done by computing.
		// a mod N = REDC(aR mod N)
		const _2kp1 = 2 * this.k + 1;
		const _red = n_zeros(_2kp1); // TODO Use UintXArray ?
		n_copy(aRmodN, 0, this.k, _red, _2kp1 - this.k);
		_redc(this.b, this.k, this.N, 0, this.k, this.M, 0, this.k, _red, 0, _2kp1);
		const i = n_trim_positive(_red, this.k + 1, _2kp1);
		const red = n_alloc(_2kp1 - i); // TODO Use UintXArray ?
		n_copy(_red, i, _2kp1, red, 0);
		return red;
	}

	mul(aRmodN, bRmodN) {
		const _2kp1 = 2 * this.k + 1;
		const abRmodN = n_zeros(_2kp1);

		_mul(this.b, this.N, this.M, aRmodN, bRmodN, abRmodN);

		return modR(this.k, abRmodN);
	}

	add(aRmodN, bRmodN) {
		const aRpbRmodN = n_alloc(this.k);
		n_copy(aRmodN, 0, this.k, aRpbRmodN, 0);
		_iadd(this.b, this.N, aRpbRmodN, bRmodN);
		return aRpbRmodN;
	}

	sub(aRmodN, bRmodN) {
		const aRpbRmodN = n_alloc(this.k);
		n_copy(aRmodN, 0, this.k, aRpbRmodN, 0);
		_isub(this.b, this.N, aRpbRmodN, bRmodN);
		return aRpbRmodN;
	}

	inv(aRmodN) {
		// The modular inverse
		// Compute (aR mod N)^-1 using Euclidean algo
		const ai = n_trim_positive(aRmodN, 0, this.k);

		let [
			GCD,
			GCDi,
			// eslint-disable-next-line no-unused-vars
			_S,
			// eslint-disable-next-line no-unused-vars
			_Si,
			aRmodNi,
			// eslint-disable-next-line no-unused-vars
			_1,
			// eslint-disable-next-line no-unused-vars
			_2,
			// eslint-disable-next-line no-unused-vars
			_3,
			// eslint-disable-next-line no-unused-vars
			_4,
			// eslint-disable-next-line no-unused-vars
			_5,
			steps,
		] = n_extended_euclidean_algorithm(
			this.b,
			this.N,
			0,
			this.k,
			aRmodN,
			ai,
			this.k,
		);

		// Assert that GCD(N,aRmodN) is 1.
		if (GCD.length - GCDi !== 1 || GCD[GCDi] !== 1)
			throw new Error(&apos;aRmodN has no inverse modulo N&apos;);

		const _2kp1 = 2 * this.k + 1;
		const red = n_zeros(_2kp1); // TODO Use UintXArray ?

		if (steps % 2 === 1) {
			// We compute N - aRmodNi
			const temporary = n_zeros(this.k);
			n_sub(
				this.b,
				this.N,
				0,
				this.k,
				aRmodNi,
				0,
				this.k,
				temporary,
				0,
				this.k,
			);
			aRmodNi = temporary;
		}

		// A^-1 R mod N = REDC((aR mod N)^-1(R^3 mod N)).
		_mul(this.b, this.N, this.M, this.R3, aRmodNi, red);

		return modR(this.k, red);
	}

	pown(aRmodN, x) {
		// Modular
		// exponentiation can be done using exponentiation by squaring by initializing the
		// initial product to the Montgomery representation of 1, that is, to R mod N, and
		// by replacing the multiply and square steps by Montgomery multiplies.

		const nonneg = x &gt;= 0;

		if (!nonneg) x = -x;

		if (x === 0) return this.R;
		if (x === 1) return nonneg ? aRmodN : this.inv(aRmodN);

		const xbits = [];

		do {
			xbits.push(x &amp; 1);
			x &gt;&gt;= 1;
		} while (x !== 1);

		return this._powb(aRmodN, xbits, nonneg);
	}

	_powb(aRmodN, xbits, nonneg) {
		// The binary expansion of the exponent is 1 concatenanted with xbits
		// reversed. Must have xbits.length &gt;= 1.
		const aRmodNpown = n_alloc(this.k);
		n_copy(aRmodN, 0, this.k, aRmodNpown, 0);

		const _2kp1 = 2 * this.k + 1;
		const temporary = n_alloc(_2kp1);

		do {
			n_reset(temporary, 0, _2kp1);
			_mul(this.b, this.N, this.M, aRmodNpown, aRmodNpown, temporary);
			n_copy(temporary, _2kp1 - this.k, _2kp1, aRmodNpown, 0);
			if (xbits.pop() === 1) {
				n_reset(temporary, 0, _2kp1);
				_mul(this.b, this.N, this.M, aRmodNpown, aRmodN, temporary);
				n_copy(temporary, _2kp1 - this.k, _2kp1, aRmodNpown, 0);
			}
		} while (xbits.length &gt; 0);

		return nonneg ? aRmodNpown : this.inv(aRmodNpown);
	}

	pow(aRmodN, b, nonneg = true) {
		if (njz(b, 0, b.length - 1)) {
			// B consists of a single limb
			return this.pown(aRmodN, nonneg ? b[b.length - 1] : -b[b.length - 1]);
		}

		const xbits = nconvert(this.b, 2, b, 0, b.length);
		xbits.reverse();
		xbits.pop();

		return this._powb(aRmodN, xbits, nonneg);
	}
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
